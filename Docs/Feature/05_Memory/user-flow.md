# 메모리 시스템 - 사용자 플로우

## 플로우 다이어그램

```
[대화 시작]
    ↓
[기존 메모리 조회]
    ↓
    ├─ [메모리 있음] → [메모리 기반 인사] → [대화 진행]
    │                                          ↓
    │                                    [세션 메모리 축적]
    │                                          ↓
    │                                    [대화 종료]
    │                                          ↓
    │                                    [자동 요약 생성]
    │                                          ↓
    │                                    [메모리 저장]
    │                                          ↓
    │                                    [메모리 제한 확인]
    │                                          ↓
    │                                    ├─ [제한 내] → [완료]
    │                                    └─ [제한 초과] → [아카이브]
    │
    └─ [메모리 없음] → [일반 인사] → [대화 진행]
```

---

## 상세 단계별 플로우

### Step 1: 대화 시작
**트리거**: 사용자가 AI 페르소나의 방 클릭 → 채팅 모달 오픈

**백엔드 프로세스**:
1. 해당 페르소나와의 활성 메모리 조회
2. 메모리를 시스템 프롬프트에 통합
3. 첫 메시지 생성

**API 호출**:
```javascript
GET /api/v1/memory/load?personaId=persona_123&limit=5

Response:
{
  "memories": [
    {
      "summary": "사용자가 어제 영화를 봤고 매우 재미있었다고 함",
      "topics": ["영화"],
      "emotion": "기쁨",
      "createdAt": "2025-10-26T20:00:00Z"
    }
  ]
}
```

**화면 전환**:
- 메모리 있음 → Step 2-A (메모리 기반 인사)
- 메모리 없음 → Step 2-B (일반 인사)

---

### Step 2-A: 메모리 기반 인사
**목표**: 과거 대화를 언급하여 연속성 제공

**AI 응답 예시**:
```
메모리: "사용자가 어제 영화를 봤고 매우 재미있었다고 함"

AI 첫 인사:
"어! 어제 본 영화 진짜 재미있었다고 했었잖아?
그거 생각하면서 오늘 하루 보냈어?"
```

**사용자 경험**:
- 사용자는 AI가 자신을 기억한다는 느낌 받음
- 대화의 자연스러운 재개

**소요 시간**: 2-3초

---

### Step 2-B: 일반 인사 (메모리 없음)
**AI 응답 예시**:
```
"어! 왔어? 오늘 뭐 했어?"
```

**사용자 경험**:
- 일반적인 대화 시작
- 메모리 축적 시작점

---

### Step 3: 대화 진행 및 세션 메모리 축적
**목표**: 현재 대화의 컨텍스트 유지

**프로세스**:
1. 사용자 메시지 입력
2. 최근 10개 메시지를 컨텍스트로 LLM에 전달
3. AI 응답 생성
4. 메시지 배열에 추가 (클라이언트 상태)

**화면 요소**:
- 채팅 인터페이스
- 메시지 입력창
- 메시지 히스토리

**기술 구현**:
```typescript
// 클라이언트 상태 관리
const [sessionMemory, setSessionMemory] = useState<Message[]>([]);

function addMessage(message: Message) {
  setSessionMemory(prev => {
    const updated = [...prev, message];
    // 최대 10개 유지
    return updated.slice(-10);
  });
}
```

**대화 예시**:
```
사용자: "오늘 회사에서 프로젝트 발표했어"
AI: "오 대박! 어떻게 됐어?"
사용자: "생각보다 잘 됐어. 팀장님이 칭찬해줬어"
AI: "와 진짜? 축하해!! 준비 많이 했으니까 당연하지 😊"
```

---

### Step 4: 대화 종료
**트리거**:
- 사용자가 채팅 모달 닫기
- 30분 이상 비활성
- 브라우저 창 닫기

**프로세스**:
1. 현재 세션 메시지 수 확인
2. 20개 이상일 경우 → Step 5 (자동 요약)
3. 20개 미만일 경우 → 저장 없이 종료

**UI 표시 (선택)**:
```
[모달 닫기 시]
"대화를 저장할까요?"
[저장] [저장 안 함]
```

**이벤트 로깅**:
```javascript
window.addEventListener('beforeunload', async () => {
  if (sessionMemory.length >= 20) {
    await saveConversationMemory();
  }
});
```

---

### Step 5: 자동 요약 생성
**목표**: LLM을 사용하여 대화의 핵심 추출

**화면 요소**:
- 로딩 인디케이터 (선택)
- "대화 내용을 저장하고 있어요..." (선택)

**백엔드 프로세스**:
1. 세션의 모든 메시지 수집
2. LLM에 요약 프롬프트 전송
3. 요약 결과 파싱 (JSON)
4. 중요도 자동 계산

**API 호출**:
```javascript
POST /api/v1/memory/summarize
{
  "sessionId": "session_789",
  "personaId": "persona_123",
  "messages": [
    { "role": "user", "content": "오늘 회사에서 프로젝트 발표했어" },
    { "role": "assistant", "content": "오 대박! 어떻게 됐어?" },
    // ... 전체 대화
  ]
}

Response:
{
  "memory": {
    "summary": "사용자가 회사에서 프로젝트 발표를 성공적으로 마쳤고 팀장에게 칭찬받음",
    "topics": ["업무", "발표", "성취"],
    "emotion": "기쁨",
    "importance": 8
  }
}
```

**소요 시간**: 3-5초

**예외 처리**:
- LLM 실패 시 → Fallback: 대화 원문 일부 저장 (최대 500자)

---

### Step 6: 메모리 저장
**목표**: 요약된 메모리를 DB에 영구 저장

**프로세스**:
1. 메모리 데이터 생성
2. DB INSERT
3. 클라이언트 상태 업데이트

**데이터베이스 저장**:
```sql
INSERT INTO memories (user_id, persona_id, session_id, summary, topics, emotion, importance)
VALUES (
  'user_456',
  'persona_123',
  'session_789',
  '사용자가 회사에서 프로젝트 발표를 성공적으로 마쳤고 팀장에게 칭찬받음',
  ARRAY['업무', '발표', '성취'],
  '기쁨',
  8
);
```

**응답**:
```javascript
{
  "success": true,
  "memory": {
    "id": "memory_101112",
    "summary": "...",
    "createdAt": "2025-10-27T18:30:00Z"
  }
}
```

---

### Step 7: 메모리 제한 확인 (무료 플랜)
**목표**: 무료 플랜 사용자의 메모리 개수 제한 적용

**조건**:
- 무료 플랜: 최대 5개 활성 메모리
- 유료 플랜: 무제한

**프로세스**:
1. 현재 활성 메모리 개수 확인
2. 5개 초과 시 → Step 7-A (아카이브)
3. 5개 이하 시 → Step 8 (완료)

**API 호출**:
```javascript
GET /api/v1/memory/count?personaId=persona_123

Response:
{
  "activeCount": 6,
  "limit": 5,
  "needsArchive": true
}
```

---

### Step 7-A: 자동 아카이브
**목표**: 중요도가 낮은 메모리를 아카이브하여 제한 준수

**화면 요소 (선택)**:
```
[알림 배너]
"메모리가 가득 찼습니다.
중요도가 낮은 이전 대화는 아카이브됩니다."

[Knock Plus 업그레이드] [확인]
```

**백엔드 프로세스**:
1. 중요도 및 생성일 기준으로 정렬
2. 6번째 이후 메모리 아카이브
3. `archived_at` 타임스탬프 업데이트

**API 호출**:
```javascript
POST /api/v1/memory/auto-archive
{
  "personaId": "persona_123"
}

Response:
{
  "success": true,
  "archivedCount": 1,
  "archivedMemories": [
    {
      "id": "memory_old",
      "summary": "일반적인 대화 내용",
      "importance": 3
    }
  ]
}
```

**사용자 경험**:
- 투명한 아카이브 프로세스
- 프리미엄 업그레이드 유도

---

### Step 8: 완료
**결과**:
- 메모리 저장 완료
- 다음 대화 시 활용 가능

**클라이언트 상태**:
```javascript
// 세션 메모리 클리어
setSessionMemory([]);

// 로컬 캐시 업데이트
updateMemoryCache(newMemory);
```

---

## 전체 타임라인

| Step | 화면/프로세스 | 평균 소요 시간 | 누적 시간 |
|------|---------------|----------------|-----------|
| 1 | 대화 시작 | 0초 | 0초 |
| 2-A | 메모리 기반 인사 | 3초 | 3초 |
| 3 | 대화 진행 (20개 메시지) | 10분 | 10분 3초 |
| 4 | 대화 종료 트리거 | 0초 | 10분 3초 |
| 5 | 자동 요약 생성 | 5초 | 10분 8초 |
| 6 | 메모리 저장 | 1초 | 10분 9초 |
| 7 | 메모리 제한 확인 | 0.5초 | 10분 9.5초 |
| 7-A | 자동 아카이브 (필요시) | 1초 | 10분 10.5초 |
| 8 | 완료 | 0초 | 10분 10.5초 |

**백그라운드 처리 시간**: 약 7-10초 (사용자는 대화 종료 후 곧바로 이탈 가능)

---

## 사용자 시나리오

### 시나리오 1: 첫 대화 (메모리 없음)
**Day 1 - 저녁 8시**

1. 사용자가 룸메이트 방 클릭
2. AI: "어! 왔어? 오늘 뭐 했어?"
3. 사용자: "새로운 게임 시작했어!"
4. AI: "오 뭔데? 재밌어?"
5. [20개 메시지 대화...]
6. 사용자가 채팅 모달 닫기
7. 백그라운드에서 메모리 생성:
   - 요약: "사용자가 새로운 게임을 시작했고 매우 재미있다고 함"
   - 주제: ["게임", "여가"]
   - 감정: 흥분
   - 중요도: 6

---

### 시나리오 2: 연속 대화 (메모리 활용)
**Day 2 - 저녁 7시**

1. 사용자가 룸메이트 방 클릭
2. 메모리 로드: "어제 새로운 게임 시작..."
3. AI: "어제 시작한 그 게임! 오늘도 했어?"
4. 사용자: "응! 벌써 10시간 했어 ㅋㅋ"
5. AI: "와 대박 ㅋㅋ 완전 빠졌네! 어디까지 갔어?"
6. [대화 계속...]

**사용자 경험**:
- "AI가 나를 기억해!"
- 자연스러운 대화 재개
- 친밀감 증가

---

### 시나리오 3: 메모리 제한 도달 (무료 플랜)
**Day 7 - 저녁 9시**

1. 사용자가 이웃1과 대화 종료
2. 시스템: 메모리 생성 시도
3. 시스템: 현재 활성 메모리 = 5개 (제한 도달)
4. 시스템: 중요도 가장 낮은 메모리 아카이브
   - 아카이브 대상: "일반적인 날씨 대화" (중요도 2)
5. 새 메모리 저장
6. [알림 표시]
   - "메모리가 가득 찼습니다. 이전 대화가 아카이브되었습니다."
   - "Knock Plus로 업그레이드하여 무제한 메모리를 이용하세요"

**사용자 경험**:
- 제한 인지
- 프리미엄 가치 이해
- 업그레이드 유도

---

## 화면 구성

### 화면 1: 채팅 모달 (메모리 기반 인사)
```
┌─────────────────────────────────────┐
│  ← 룸메이트                    ⋮    │
├─────────────────────────────────────┤
│                                     │
│  [AI 프로필 사진]                   │
│  어제 시작한 그 게임!               │
│  오늘도 했어?                       │
│                                     │
│               응! 벌써 10시간 했어  │
│               ㅋㅋ [사용자 사진]   │
│                                     │
│  [AI 프로필 사진]                   │
│  와 대박 ㅋㅋ 완전 빠졌네!          │
│  어디까지 갔어?                     │
│                                     │
├─────────────────────────────────────┤
│  메시지 입력...            [전송]  │
└─────────────────────────────────────┘
```

### 화면 2: 메모리 제한 알림 (무료 플랜)
```
┌─────────────────────────────────────┐
│  ⚠️ 메모리가 가득 찼습니다          │
│                                     │
│  중요도가 낮은 이전 대화는          │
│  아카이브되었습니다.                │
│                                     │
│  현재: 5/5개 활성 메모리            │
│                                     │
│  [Knock Plus 업그레이드]   [확인]  │
└─────────────────────────────────────┘
```

### 화면 3: 메모리 관리 화면 (설정)
```
┌─────────────────────────────────────┐
│  ← 메모리 관리                      │
├─────────────────────────────────────┤
│  활성 메모리 (5/5)                  │
│                                     │
│  ┌───────────────────────────────┐ │
│  │ 🎮 게임                       │ │
│  │ "사용자가 새로운 게임 시작..." │ │
│  │ 중요도: ⭐⭐⭐⭐⭐⭐ (6/10)      │ │
│  │ 2025-10-26                    │ │
│  │                      [편집] [삭제] │
│  └───────────────────────────────┘ │
│                                     │
│  ┌───────────────────────────────┐ │
│  │ 💼 업무                       │ │
│  │ "프로젝트 발표 성공..."       │ │
│  │ 중요도: ⭐⭐⭐⭐⭐⭐⭐⭐ (8/10) │ │
│  │ 2025-10-27                    │ │
│  │                      [편집] [삭제] │
│  └───────────────────────────────┘ │
│                                     │
│  아카이브된 메모리 (2)              │
│  [보기 >]                           │
└─────────────────────────────────────┘
```

---

## 이탈 방지 전략

### Critical Point 1: 대화 종료 시 로딩
**리스크**: 메모리 생성 시간이 길어 사용자 이탈

**대응**:
- 백그라운드 비동기 처리
- 사용자는 모달 닫고 즉시 이탈 가능
- 로딩 화면 불필요

### Critical Point 2: 메모리 제한 알림
**리스크**: 제한 알림이 부정적 경험

**대응**:
- 긍정적 프레이밍: "중요한 대화는 항상 기억해요"
- 프리미엄 가치 강조
- 알림 빈도 제한 (1일 1회)

---

## A/B 테스트 아이디어

### Test 1: 메모리 기반 인사 타이밍
- **A**: 대화 시작 즉시 메모리 언급
- **B**: 2-3개 메시지 교환 후 자연스럽게 언급

### Test 2: 메모리 제한 알림 방식
- **A**: 모달 팝업 (현재)
- **B**: 작은 배너 알림 (덜 침입적)

### Test 3: 메모리 요약 빈도
- **A**: 대화 종료마다 요약 (현재)
- **B**: 중요한 대화만 선별적 요약 (중요도 7+ 예측)

**측정 지표**: 메모리 활용률, 재방문율, 프리미엄 전환율
