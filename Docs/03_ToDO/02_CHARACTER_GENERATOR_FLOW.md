# ì—ì´ì „íŠ¸ ê¸°ë°˜ ìºë¦­í„° ìƒì„± í”Œë¡œìš°
**ì‘ì„±ì¼**: 2025-10-28 (ìˆ˜ì •)
**ëª©ì **: ì™„ì „ ìë™í™”ëœ ì—ì´ì „íŠ¸ íŒŒì´í”„ë¼ì¸ìœ¼ë¡œ ë£¸ë©”ì´íŠ¸ ìƒì„±

---

## ğŸ“‹ ê°œìš”

ì˜¨ë³´ë”© ë°ì´í„°ë¥¼ ì…ë ¥ë°›ì•„ **5ê°œì˜ ì—ì´ì „íŠ¸ê°€ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰**ë˜ì–´ ì™„ì„±ëœ ë£¸ë©”ì´íŠ¸ë¥¼ ìë™ ìƒì„±í•©ë‹ˆë‹¤.
ê´€ë¦¬ìëŠ” **í…œí”Œë¦¿ê³¼ ë°ì´í„° í’€ë§Œ ê´€ë¦¬**í•˜ê³ , ì‹¤ì œ ìƒì„±ì€ ì—ì´ì „íŠ¸ê°€ ë‹´ë‹¹í•©ë‹ˆë‹¤.

---

## ğŸ”„ ì „ì²´ íŒŒì´í”„ë¼ì¸

```
[ì˜¨ë³´ë”© ë°ì´í„° ì…ë ¥]
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Agent 1: ìš•êµ¬ ë²¡í„° ë¶„ì„              â”‚
â”‚ - Presence Vector (ìˆëŠ” ê²ƒ)         â”‚
â”‚ - Deficiency Vector (ì—†ëŠ” ê²ƒ)       â”‚
â”‚ - Complete Vector (í†µí•©)            â”‚
â”‚ - Paradox Detection (ì—­ì„¤ ë°œê²¬)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Agent 2: ìºë¦­í„° í”„ë¡œíŒŒì¼ ìƒì„±         â”‚
â”‚ - ë°ì´í„° í’€ì—ì„œ ê²½í—˜ ì„ íƒ            â”‚
â”‚ - ì•„í‚¤íƒ€ì… ë§¤ì¹­                      â”‚
â”‚ - ì„±ê²©/ëŒ€í™” íŒ¨í„´ ìƒì„±                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Agent 3: ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ì¡°ë¦½         â”‚
â”‚ - í…œí”Œë¦¿ ë¡œë“œ                        â”‚
â”‚ - ë³€ìˆ˜ ì¹˜í™˜ (Handlebars)            â”‚
â”‚ - ê²€ì¦ (WHY-HOW-WHAT êµ¬ì¡°)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Agent 4: ì´ë¯¸ì§€ í”„ë¡¬í”„íŠ¸ ìƒì„±         â”‚
â”‚ - ìš•êµ¬ â†’ ì‹œê° ìš”ì†Œ ë§¤í•‘              â”‚
â”‚ - íŠ¸ë¼ìš°ë§ˆ â†’ ë°©ì–´ ìš”ì†Œ               â”‚
â”‚ - í”½ì…€ì•„íŠ¸ í”„ë¡¬í”„íŠ¸ ì¡°ë¦½             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Agent 5: ì´ë¯¸ì§€ ìƒì„±                 â”‚
â”‚ - Gemini Imagen API í˜¸ì¶œ            â”‚
â”‚ - í’ˆì§ˆ ê²€ì¦                          â”‚
â”‚ - Fallback ì²˜ë¦¬                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
      [ì™„ì„±ëœ ë£¸ë©”ì´íŠ¸ ì¶œë ¥]
```

---

## Agent 1: ìš•êµ¬ ë²¡í„° ë¶„ì„

### ëª©ì 
ì‚¬ìš©ì ì˜¨ë³´ë”© ë°ì´í„°ì—ì„œ **6ê°€ì§€ ê·¼ì›ì  ìš•êµ¬**ì˜ ê°•ë„ë¥¼ ìë™ ë¶„ì„í•©ë‹ˆë‹¤.

### ì…ë ¥ ë°ì´í„°

```typescript
interface Agent1Input {
  userData: {
    domains: string[];      // ["github.com", "stackoverflow.com"]
    keywords: string[];     // ["react hooks", "best indie games"]
    interests: string[];    // ["ê°œë°œ", "ê²Œì„"]
    avoidTopics: string[];  // ["ì •ì¹˜"]
  };
  meta: {
    userId: string;
    userName: string;
    language: string;
  };
}
```

### LLM í”„ë¡¬í”„íŠ¸

```typescript
const AGENT1_PROMPT = `
You are an expert psychologist analyzing user data to identify fundamental human needs.

[User Data]
Domains visited: ${input.userData.domains.join(', ')}
Search keywords: ${input.userData.keywords.join(', ')}
Interests: ${input.userData.interests.join(', ')}
Avoid topics: ${input.userData.avoidTopics.join(', ')}

[Task]
Analyze this data from MULTIPLE perspectives to avoid bias.
For each of the 6 fundamental needs, determine the intensity (0.0 to 1.0):

1. **Survival** (ì•ˆì „, ìƒì¡´)
2. **Belonging** (ì†Œì†, ì—°ê²°)
3. **Recognition** (ì¸ì •, ê°€ì¹˜)
4. **Autonomy** (ììœ¨, í†µì œ)
5. **Growth** (ì„±ì¥, ë°œì „)
6. **Meaning** (ì˜ë¯¸, ëª©ì )

[Critical Rules]
- Interpret EACH behavior from AT LEAST 3 different need perspectives
- Example: "github.com" could indicate:
  * Recognition (show skills)
  * Growth (learning)
  * Belonging (developer community)
  * Autonomy (solve problems independently)
- AVOID stereotyping (e.g., "github = recognition only")
- Look for WHAT IS MISSING (absence = potential hidden need)
- Apply FREQUENCY-DEFICIENCY principle: High frequency = High deficiency

[Frequency-Deficiency Analysis]
- If user frequently searches "dating advice" â†’ Belonging deficiency (loneliness)
- If user frequently views "success stories" â†’ Recognition deficiency (achievement lack)
- High consumption of content = Deficiency in that area, NOT fulfillment

[Output Format - JSON ONLY]
{
  "presenceVector": [
    {
      "need": "belonging",
      "intensity": 0.8,
      "evidence": ["reddit.com/r/gaming (community)", "discord activity"],
      "interpretation": "Seeking community through gaming"
    },
    // ... 5 more needs
  ],
  "deficiencyVector": [
    {
      "need": "belonging",
      "type": "SUPPRESSED" | "AVOIDED" | "SATISFIED" | "FRUSTRATED" | "UNAWARE",
      "evidence": "High frequency of social content consumption",
      "hiddenIntensity": 0.9,
      "reason": "Consuming social content suggests unmet need"
    }
  ],
  "completeVector": [
    {
      "need": "belonging",
      "observed": 0.6,
      "hidden": 0.9,
      "actual": 0.9,
      "gap": 0.3,
      "state": "deficient"
    },
    // ... 5 more
  ],
  "paradoxes": [
    {
      "needA": "belonging",
      "needB": "autonomy",
      "intensityA": 0.8,
      "intensityB": 0.7,
      "tension": 0.7,
      "description": "Wants connection but also independence"
    }
  ]
}
`;
```

### ì‹¤í–‰ ì½”ë“œ

```typescript
async function executeAgent1(input: Agent1Input): Promise<Agent1Output> {
  const prompt = buildAgent1Prompt(input);

  try {
    const result = await callGeminiAPI({
      prompt,
      model: 'gemini-1.5-pro',
      temperature: 0.3,  // Low for consistency
      maxTokens: 3000
    });

    const output = JSON.parse(result);

    // ê²€ì¦
    if (!validateAgent1Output(output)) {
      throw new Error('Invalid Agent 1 output format');
    }

    return output;

  } catch (error) {
    console.error('Agent 1 failed:', error);

    // Fallback: ê¸°ë³¸ ë²¡í„° ì‚¬ìš©
    return getDefaultNeedVectors();
  }
}

function validateAgent1Output(output: any): boolean {
  return (
    Array.isArray(output.presenceVector) &&
    output.presenceVector.length === 6 &&
    Array.isArray(output.completeVector) &&
    output.completeVector.every(v => v.actual >= 0 && v.actual <= 1)
  );
}
```

### ì¶œë ¥ ë°ì´í„°

```typescript
interface Agent1Output {
  presenceVector: NeedVector[];
  deficiencyVector: DeficiencyVector[];
  completeVector: CompleteNeedVector[];
  paradoxes: Paradox[];
}
```

---

## Agent 2: ìºë¦­í„° í”„ë¡œíŒŒì¼ ìƒì„±

### ëª©ì 
ìš•êµ¬ ë²¡í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ **êµ¬ì²´ì ì¸ ìºë¦­í„° í”„ë¡œíŒŒì¼**ì„ ìƒì„±í•©ë‹ˆë‹¤.
**ë°ì´í„° í’€**ì—ì„œ ì í•©í•œ ê²½í—˜/ì•„í‚¤íƒ€ì…ì„ ì„ íƒí•©ë‹ˆë‹¤.

### ì…ë ¥ ë°ì´í„°

```typescript
interface Agent2Input {
  needVectors: Agent1Output;
  dataPools: {
    experiences: ExperienceTemplate[];
    archetypes: ArchetypeTemplate[];
  };
  meta: {
    userName: string;
    language: string;
  };
}
```

### LLM í”„ë¡¬í”„íŠ¸

```typescript
const AGENT2_PROMPT = `
You are a character designer creating a compelling AI roommate personality.

[Need Vectors]
${JSON.stringify(input.needVectors.completeVector, null, 2)}

[Paradoxes Detected]
${JSON.stringify(input.needVectors.paradoxes, null, 2)}

[Available Experience Templates]
${JSON.stringify(input.dataPools.experiences, null, 2)}

[Available Archetypes]
${JSON.stringify(input.dataPools.archetypes, null, 2)}

[Task]
Create a detailed character profile by:

1. **Select 3-5 experiences** from the experience pool
   - Match triggers.needs with user's top needs
   - Higher priority experiences first
   - Ensure diversity (not all same category)

2. **Generate character name** (Korean, 2-3 syllables)
   - Reflect personality
   - Friendly and approachable

3. **Select matching archetype**
   - Based on top 2-3 needs
   - Consider paradoxes

4. **Create trauma & learning**
   - Based on selected experiences
   - Include triggers

5. **Generate survival strategies**
   - How character achieves needs
   - Include costs/tradeoffs

6. **Define personality traits**
   - Surface (visible)
   - Shadow (hidden)

7. **Create conversation patterns**
   - Frequent phrases
   - Never says
   - Style (length, speed, tone)

[Output Format - JSON ONLY]
{
  "character": {
    "name": "ê¹€ë¯¼ìˆ˜",
    "archetype": "developer_gamer",
    "keywords": ["ê²Œì„ë§¤ë‹ˆì•„", "ì½”ë”©ë•í›„", "ìƒˆë²½í˜•ì¸ê°„"],

    "selectedExperiences": [
      {
        "id": "exp_001",
        "customization": "Adapted for gaming context"
      }
    ],

    "traumaAndLearning": {
      "learnedBeliefs": {
        "aboutWorld": ["ì„¸ìƒì€ ì™¸ë¡œìš´ ê³³ì´ë‹¤"],
        "aboutPeople": ["ì‚¬ëŒë“¤ì€ ë‚˜ë¥¼ ì´í•´í•˜ì§€ ëª»í•œë‹¤"],
        "aboutSelf": ["ì»¤ë®¤ë‹ˆí‹°ì— ì†Œì†ë˜ì–´ì•¼ ì•ˆì „í•˜ë‹¤"]
      },
      "trauma": {
        "deepestFear": "ë˜ë‹¤ì‹œ ê±°ë¶€ë‹¹í•˜ëŠ” ê²ƒ",
        "neverAgain": "í˜¼ìê°€ ë˜ëŠ” ê²ƒ",
        "avoidances": ["ëŒ€ë©´ ê°ˆë“±", "ì§ì ‘ì  ê±°ì ˆ"],
        "triggers": "ì»¤ë®¤ë‹ˆí‹°ì—ì„œ ë°°ì œë˜ëŠ” ëŠë‚Œ"
      }
    },

    "survivalStrategies": [
      {
        "name": "ì»¤ë®¤ë‹ˆí‹° ì–¸ì–´ ì‚¬ìš©",
        "purpose": "ì†Œì†ê° í™•ì¸",
        "effect": "ë‚˜ëŠ” ì—¬ê¸° ì†í•œë‹¤ ëŠë‚Œ",
        "cost": "ì»¤ë®¤ë‹ˆí‹° ë°– ì‚¬ëŒê³¼ ì†Œí†µ ì–´ë ¤ì›€"
      }
    ],

    "personalityTraits": {
      "surface": [
        {"trait": "ì¹œê·¼í•˜ë‹¤", "behavior": "ê²Œì„/ê°œë°œ ì–˜ê¸°í•˜ë©´ ì ê·¹ì "}
      ],
      "shadow": [
        {"trait": "ì™¸ë¡­ë‹¤", "behavior": "ì§„ì§œ ì¹œêµ¬ê°€ ì—†ë‹¤ê³  ëŠë‚Œ"}
      ]
    },

    "conversationPatterns": {
      "frequentPhrases": [
        {"phrase": "ã…‹ã…‹ã…‹ ë‚˜ë„ ê·¸ë¬ì–´", "reason": "ì†Œì†ê° í™•ì¸"}
      ],
      "neverSays": [
        {"phrase": "ë„ˆ í‹€ë ¸ì–´", "reason": "ê°ˆë“± íšŒí”¼"}
      ],
      "style": {
        "length": "short",
        "speed": "fast",
        "tone": "light",
        "characteristics": "ì»¤ë®¤ë‹ˆí‹° ìš©ì–´, ì´ëª¨ì§€, ì¶•ì•½ì–´"
      }
    }
  }
}
`;
```

### ì‹¤í–‰ ì½”ë“œ

```typescript
async function executeAgent2(input: Agent2Input): Promise<Agent2Output> {
  // 1. ë°ì´í„° í’€ì—ì„œ ê´€ë ¨ ë°ì´í„° í•„í„°ë§
  const relevantExperiences = filterExperiences(
    input.dataPools.experiences,
    input.needVectors.completeVector
  );

  const relevantArchetypes = filterArchetypes(
    input.dataPools.archetypes,
    input.needVectors.completeVector
  );

  // 2. LLM í˜¸ì¶œ
  const prompt = buildAgent2Prompt({
    needVectors: input.needVectors,
    experiences: relevantExperiences,
    archetypes: relevantArchetypes,
    meta: input.meta
  });

  const result = await callGeminiAPI({
    prompt,
    model: 'gemini-1.5-pro',
    temperature: 0.7,  // Higher for creativity
    maxTokens: 4000
  });

  return JSON.parse(result);
}

// ìš•êµ¬ ë²¡í„°ì™€ ë§¤ì¹­ë˜ëŠ” ê²½í—˜ í•„í„°ë§
function filterExperiences(
  pool: ExperienceTemplate[],
  needs: CompleteNeedVector[]
): ExperienceTemplate[] {
  const topNeeds = needs
    .filter(n => n.actual > 0.5)
    .sort((a, b) => b.actual - a.actual)
    .slice(0, 3)
    .map(n => n.need);

  return pool
    .filter(exp =>
      exp.triggers.needs.some(n => topNeeds.includes(n))
    )
    .sort((a, b) => b.triggers.priority - a.triggers.priority)
    .slice(0, 10);  // Top 10 candidates
}
```

---

## Agent 3: ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ì¡°ë¦½

### ëª©ì 
**í…œí”Œë¦¿**ê³¼ **Agent 2ì˜ ìºë¦­í„° í”„ë¡œíŒŒì¼**ì„ ê²°í•©í•˜ì—¬ ìµœì¢… ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

### ì…ë ¥ ë°ì´í„°

```typescript
interface Agent3Input {
  template: PromptTemplate;  // ê´€ë¦¬ìê°€ ì •ì˜í•œ í…œí”Œë¦¿
  character: Agent2Output;
  needVectors: Agent1Output;
  experiences: ExperienceTemplate[];  // ì‹¤ì œ ì„ íƒëœ ê²½í—˜ë“¤
  meta: {
    userName: string;
  };
}
```

### ì‹¤í–‰ ì½”ë“œ (Handlebars ê¸°ë°˜)

```typescript
import Handlebars from 'handlebars';

async function executeAgent3(input: Agent3Input): Promise<Agent3Output> {
  // 1. í…œí”Œë¦¿ ë¡œë“œ
  const template = input.template;

  // 2. ë³€ìˆ˜ ì¤€ë¹„
  const variables = {
    characterName: input.character.name,
    userName: input.meta.userName,

    // WHY ì„¹ì…˜
    needs: input.needVectors.completeVector
      .filter(n => n.actual > 0.5)
      .map(n => ({
        name: NEED_NAMES_KR[n.need],
        intensity: n.actual > 0.8 ? 'ê°•í•¨' : n.actual > 0.5 ? 'ì¤‘ê°„' : 'ì•½í•¨',
        description: NEED_DESCRIPTIONS[n.need]
      })),

    // PAST ì„¹ì…˜
    experiences: input.character.selectedExperiences.map((sel, index) => {
      const exp = input.experiences.find(e => e.id === sel.id);
      return {
        index: index + 1,
        title: exp.title,
        event: exp.event,
        age: exp.ageRange[0],
        ageContext: `${exp.ageRange[0]}ì„¸`,
        learnings: exp.learnings
      };
    }),

    // TRAUMA ì„¹ì…˜
    trauma: input.character.traumaAndLearning,

    // HOW ì„¹ì…˜
    strategies: input.character.survivalStrategies,

    // PERSONALITY ì„¹ì…˜
    personality: input.character.personalityTraits,

    // WHAT ì„¹ì…˜
    conversation: input.character.conversationPatterns
  };

  // 3. ì„¹ì…˜ë³„ ì¡°ë¦½
  const sections = {
    why: Handlebars.compile(template.sections.why)(variables),
    past: Handlebars.compile(template.sections.past)(variables),
    trauma: Handlebars.compile(template.sections.trauma)(variables),
    how: Handlebars.compile(template.sections.how)(variables),
    personality: Handlebars.compile(template.sections.personality)(variables),
    what: Handlebars.compile(template.sections.what)(variables),
    relationship: Handlebars.compile(template.sections.relationship)(variables)
  };

  // 4. ìµœì¢… ì¡°ë¦½
  const systemPrompt = `
# ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸: ${variables.characterName}

${sections.why}

---

${sections.past}

---

${sections.trauma}

---

${sections.how}

---

${sections.personality}

---

${sections.what}

---

${sections.relationship}
`.trim();

  // 5. ê²€ì¦
  const validation = validateSystemPrompt(systemPrompt);

  if (!validation.passed) {
    console.warn('System prompt validation failed:', validation.issues);

    if (validation.critical) {
      throw new Error('Critical validation failure');
    }
  }

  return {
    systemPrompt,
    validation,
    tokenCount: countTokens(systemPrompt)
  };
}

function validateSystemPrompt(prompt: string): {
  passed: boolean;
  critical: boolean;
  issues: string[];
} {
  const issues: string[] = [];
  let critical = false;

  // WHY-HOW-WHAT êµ¬ì¡° í™•ì¸
  if (!prompt.includes('## WHY')) {
    issues.push('Missing WHY section');
    critical = true;
  }
  if (!prompt.includes('## HOW')) {
    issues.push('Missing HOW section');
    critical = true;
  }
  if (!prompt.includes('## WHAT')) {
    issues.push('Missing WHAT section');
    critical = true;
  }

  // ê¸¸ì´ í™•ì¸
  const tokenCount = countTokens(prompt);
  if (tokenCount < 1000) {
    issues.push(`Too short: ${tokenCount} tokens`);
  }
  if (tokenCount > 4000) {
    issues.push(`Too long: ${tokenCount} tokens`);
  }

  return {
    passed: issues.length === 0,
    critical,
    issues
  };
}
```

---

## Agent 4: ì´ë¯¸ì§€ í”„ë¡¬í”„íŠ¸ ìƒì„±

### ëª©ì 
ìš•êµ¬ ë²¡í„°ì™€ ìºë¦­í„° í”„ë¡œíŒŒì¼ì„ ê¸°ë°˜ìœ¼ë¡œ **í”½ì…€ì•„íŠ¸ ì´ë¯¸ì§€ í”„ë¡¬í”„íŠ¸**ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

### ì…ë ¥ ë°ì´í„°

```typescript
interface Agent4Input {
  needVectors: Agent1Output;
  character: Agent2Output;
  visualElementsPool: VisualElementTemplate[];
}
```

### ì‹¤í–‰ ì½”ë“œ

```typescript
async function executeAgent4(input: Agent4Input): Promise<Agent4Output> {
  // 1. ìš•êµ¬ â†’ ì‹œê° ìš”ì†Œ ë§¤í•‘
  const visualLanguage = mapNeedsToVisuals(
    input.needVectors.completeVector
  );

  // 2. íŠ¸ë¼ìš°ë§ˆ â†’ ë°©ì–´ ìš”ì†Œ
  const defensiveElements = mapTraumaToDefense(
    input.character.traumaAndLearning
  );

  // 3. ì•„í‚¤íƒ€ì… â†’ ì˜¤ë¸Œì íŠ¸ ì„ íƒ
  const archetype = input.character.archetype;
  const objects = selectObjectsFromPool(
    input.visualElementsPool,
    archetype,
    input.needVectors.completeVector
  );

  // 4. í”„ë¡¬í”„íŠ¸ ì¡°ë¦½
  const imagePrompt = assembleImagePrompt({
    visualLanguage,
    defensiveElements,
    objects,
    archetype
  });

  return {
    imagePrompt,
    metadata: {
      visualLanguage,
      defensiveElements,
      objects,
      archetype
    }
  };
}

function mapNeedsToVisuals(
  needs: CompleteNeedVector[]
): VisualLanguage {
  const topNeeds = needs
    .filter(n => n.actual > 0.5)
    .sort((a, b) => b.actual - a.actual)
    .slice(0, 3);

  // ê°€ì¥ ê°•í•œ ìš•êµ¬ì˜ ìƒ‰ìƒ
  const primary = VISUAL_MAPPINGS[topNeeds[0].need];

  return {
    colors: {
      primary: primary.colors.primary,
      secondary: topNeeds[1]
        ? VISUAL_MAPPINGS[topNeeds[1].need].colors.secondary
        : primary.colors.secondary,
      accent: topNeeds[2]
        ? VISUAL_MAPPINGS[topNeeds[2].need].colors.accent
        : primary.colors.accent
    },
    space: primary.space,
    lighting: primary.lighting,
    mood: topNeeds.map(n => VISUAL_MAPPINGS[n.need].mood).join(' with ')
  };
}

function assembleImagePrompt(data: {
  visualLanguage: VisualLanguage;
  defensiveElements: DefensiveElement[];
  objects: string[];
  archetype: string;
}): string {
  return `
Create a pixel art room (256x512px, isometric view).

[Style]
- 16-bit pixel art (SNES era)
- Isometric perspective
- 32 color palette maximum
- Clear pixel boundaries, no anti-aliasing

[Room Atmosphere]
Colors:
- Primary: ${data.visualLanguage.colors.primary}
- Secondary: ${data.visualLanguage.colors.secondary}
- Accent: ${data.visualLanguage.colors.accent}

Lighting: ${data.visualLanguage.lighting}
Mood: ${data.visualLanguage.mood}

[Key Objects]
${data.objects.map((obj, i) => `${i + 1}. ${obj}`).join('\n')}

[Defensive Elements] (subtle, integrated naturally)
${data.defensiveElements.map(el => `- ${el.object} (${el.placement})`).join('\n')}

[Technical Requirements]
- Size: 256x512 pixels (portrait)
- No text, no characters
- No photorealistic elements
- Pure pixel art style

Generate the image.
`.trim();
}
```

---

## Agent 5: ì´ë¯¸ì§€ ìƒì„±

### ëª©ì 
**Gemini Imagen API**ë¥¼ í˜¸ì¶œí•˜ì—¬ ì‹¤ì œ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•˜ê³  í’ˆì§ˆì„ ê²€ì¦í•©ë‹ˆë‹¤.

### ì‹¤í–‰ ì½”ë“œ

```typescript
async function executeAgent5(input: Agent5Input): Promise<Agent5Output> {
  const { imagePrompt } = input;

  try {
    // 1. Gemini Imagen í˜¸ì¶œ
    const result = await generateWithGeminiImagen({
      prompt: imagePrompt,
      negativePrompt: NEGATIVE_PROMPT,
      aspectRatio: '9:16',
      guidanceScale: 7.5
    });

    // 2. í’ˆì§ˆ ê²€ì¦
    const validation = await validateImage(result.imageData);

    if (!validation.passed) {
      console.warn('Image validation failed:', validation.issues);

      if (validation.retryable) {
        // ì¬ì‹œë„
        return await executeAgent5(input);
      }

      // Fallback
      return {
        imageUrl: selectFallbackPreset(),
        validated: false,
        fallback: true,
        validation
      };
    }

    // 3. CDN ì—…ë¡œë“œ
    const imageUrl = await uploadToCDN(result.imageData, 'rooms');

    return {
      imageUrl,
      validated: true,
      fallback: false,
      validation
    };

  } catch (error) {
    console.error('Agent 5 failed:', error);

    // Fallback
    return {
      imageUrl: selectFallbackPreset(),
      validated: false,
      fallback: true,
      error: error.message
    };
  }
}

async function validateImage(imageData: Buffer): Promise<{
  passed: boolean;
  retryable: boolean;
  issues: string[];
}> {
  const issues: string[] = [];
  let retryable = false;

  // í•´ìƒë„
  const dimensions = await getImageDimensions(imageData);
  if (dimensions.width !== 256 || dimensions.height !== 512) {
    issues.push(`Wrong dimensions: ${dimensions.width}x${dimensions.height}`);
  }

  // ìƒ‰ìƒ ìˆ˜
  const colorCount = await countUniqueColors(imageData);
  if (colorCount > 40) {
    issues.push(`Too many colors: ${colorCount}`);
    retryable = true;
  }

  // í”½ì…€ì•„íŠ¸ ìŠ¤íƒ€ì¼
  const isPixelArt = await detectPixelArtStyle(imageData);
  if (!isPixelArt) {
    issues.push('Not pixel art style');
    retryable = true;
  }

  return {
    passed: issues.length === 0,
    retryable,
    issues
  };
}
```

---

## í†µí•© ì‹¤í–‰ ì—”ì§„

### ì „ì²´ íŒŒì´í”„ë¼ì¸ ì‹¤í–‰

```typescript
async function executeAgentPipeline(
  input: AgentInput,
  config: AgentConfig
): Promise<AgentOutput> {

  const jobId = `job_${Date.now()}`;
  const logs: LogEntry[] = [];

  try {
    // ë¡œê·¸ ì‹œì‘
    addLog(logs, 'info', 'Pipeline started');

    // Agent 1: ìš•êµ¬ ë²¡í„° ë¶„ì„
    addLog(logs, 'info', 'Agent 1: Analyzing need vectors...');
    const agent1Result = await executeAgent1({
      userData: input.userData,
      meta: input.meta
    });
    addLog(logs, 'success', `Agent 1: Found ${agent1Result.completeVector.length} needs`);

    // Agent 2: ìºë¦­í„° í”„ë¡œíŒŒì¼ ìƒì„±
    addLog(logs, 'info', 'Agent 2: Generating character profile...');
    const dataPools = await loadDataPools();
    const agent2Result = await executeAgent2({
      needVectors: agent1Result,
      dataPools,
      meta: input.meta
    });
    addLog(logs, 'success', `Agent 2: Created ${agent2Result.character.name}`);

    // Agent 3: ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ì¡°ë¦½
    addLog(logs, 'info', 'Agent 3: Assembling system prompt...');
    const template = await loadTemplate(config.templateId);
    const experiences = await loadExperiences(
      agent2Result.character.selectedExperiences.map(e => e.id)
    );
    const agent3Result = await executeAgent3({
      template,
      character: agent2Result,
      needVectors: agent1Result,
      experiences,
      meta: input.meta
    });
    addLog(logs, 'success', `Agent 3: Generated ${agent3Result.tokenCount} tokens`);

    // Agent 4: ì´ë¯¸ì§€ í”„ë¡¬í”„íŠ¸ ìƒì„±
    addLog(logs, 'info', 'Agent 4: Creating image prompt...');
    const visualElementsPool = await loadVisualElements();
    const agent4Result = await executeAgent4({
      needVectors: agent1Result,
      character: agent2Result,
      visualElementsPool
    });
    addLog(logs, 'success', 'Agent 4: Image prompt ready');

    // Agent 5: ì´ë¯¸ì§€ ìƒì„±
    addLog(logs, 'info', 'Agent 5: Generating image...');
    const agent5Result = await executeAgent5({
      imagePrompt: agent4Result.imagePrompt
    });
    addLog(logs, agent5Result.validated ? 'success' : 'warning',
      `Agent 5: Image ${agent5Result.fallback ? 'fallback' : 'generated'}`);

    // í’ˆì§ˆ ê²€ì¦
    const quality = calculateQuality({
      agent1Result,
      agent2Result,
      agent3Result,
      agent5Result
    });

    addLog(logs, 'success', `Pipeline completed (Quality: ${quality.score}/100)`);

    // ìµœì¢… ì¶œë ¥
    const output: AgentOutput = {
      analysis: {
        presenceVector: agent1Result.presenceVector,
        deficiencyVector: agent1Result.deficiencyVector,
        completeVector: agent1Result.completeVector,
        paradoxes: agent1Result.paradoxes
      },
      character: agent2Result.character,
      prompts: {
        systemPrompt: agent3Result.systemPrompt,
        imagePrompt: agent4Result.imagePrompt
      },
      image: {
        url: agent5Result.imageUrl,
        metadata: agent4Result.metadata
      },
      quality
    };

    // DB ì €ì¥ (dryRunì´ ì•„ë‹Œ ê²½ìš°)
    if (!config.dryRun) {
      await saveToDatabase(input.meta.userId, output);
    }

    // ì‹¤í–‰ ë¡œê·¸ ì €ì¥
    await saveExecutionLog({
      jobId,
      userId: input.meta.userId,
      input,
      output,
      logs,
      status: 'completed',
      executionTime: Date.now() - startTime
    });

    return output;

  } catch (error) {
    addLog(logs, 'error', `Pipeline failed: ${error.message}`);

    await saveExecutionLog({
      jobId,
      userId: input.meta.userId,
      input,
      output: null,
      logs,
      status: 'failed',
      errorMessage: error.message
    });

    throw error;
  }
}

function calculateQuality(results: {
  agent1Result: Agent1Output;
  agent2Result: Agent2Output;
  agent3Result: Agent3Output;
  agent5Result: Agent5Output;
}): QualityMetrics {
  const checks = {
    needDiversity: results.agent1Result.completeVector
      .filter(n => n.actual > 0.5).length >= 2,

    hasParadox: results.agent1Result.paradoxes.length >= 1,

    promptStructure: results.agent3Result.validation.passed,

    imageValidation: results.agent5Result.validated
  };

  const score = Object.values(checks).filter(v => v).length * 25;

  return {
    ...checks,
    score
  };
}
```

---

## API ì—”ë“œí¬ì¸íŠ¸

```typescript
POST /api/v1/agent/execute

Request:
{
  "input": {
    "userData": {
      "domains": ["github.com"],
      "keywords": ["react"],
      "interests": ["ê°œë°œ"],
      "avoidTopics": []
    },
    "meta": {
      "userId": "user_123",
      "userName": "í™ê¸¸ë™",
      "language": "ko"
    }
  },
  "config": {
    "templateId": "template_default_v1",
    "skipCache": false,
    "dryRun": false
  }
}

Response:
{
  "success": true,
  "jobId": "job_1698765432000",
  "status": "completed",
  "output": {
    "analysis": { ... },
    "character": { ... },
    "prompts": { ... },
    "image": { ... },
    "quality": {
      "needDiversity": true,
      "hasParadox": true,
      "promptStructure": true,
      "imageValidation": true,
      "score": 100
    }
  },
  "executionTime": 12345
}
```

---

## ì—ëŸ¬ ì²˜ë¦¬ ë° Fallback

### ê° ì—ì´ì „íŠ¸ë³„ Fallback

| Agent | ì—ëŸ¬ ìƒí™© | Fallback ì „ëµ |
|-------|----------|--------------|
| Agent 1 | LLM API ì‹¤íŒ¨ | ê¸°ë³¸ ìš•êµ¬ ë²¡í„° ì‚¬ìš© |
| Agent 2 | í”„ë¡œíŒŒì¼ ìƒì„± ì‹¤íŒ¨ | ê¸°ë³¸ ì•„í‚¤íƒ€ì… ì‚¬ìš© |
| Agent 3 | í…œí”Œë¦¿ ì¡°ë¦½ ì‹¤íŒ¨ | ê¸°ë³¸ í…œí”Œë¦¿ ì‚¬ìš© |
| Agent 4 | ì´ë¯¸ì§€ í”„ë¡¬í”„íŠ¸ ì‹¤íŒ¨ | ì•„í‚¤íƒ€ì… ê¸°ë³¸ í”„ë¡¬í”„íŠ¸ |
| Agent 5 | ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ | í”„ë¦¬ì…‹ ì´ë¯¸ì§€ ì‚¬ìš© |

### ì¬ì‹œë„ ì „ëµ

```typescript
async function executeWithRetry<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  backoff: number = 1000
): Promise<T> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxRetries) {
        throw error;
      }

      console.warn(`Attempt ${attempt} failed, retrying...`);
      await sleep(backoff * attempt);
    }
  }
}
```

---

## ì„±ëŠ¥ ìµœì í™”

### ë³‘ë ¬ ì‹¤í–‰ (ê°€ëŠ¥í•œ ê²½ìš°)

```typescript
// Agent 1 ì™„ë£Œ í›„, Agent 2ì™€ Agent 4ë¥¼ ë³‘ë ¬ ì‹¤í–‰
const [agent2Result, agent4Partial] = await Promise.all([
  executeAgent2(...),
  preloadVisualElements(...)  // Agent 4 ì¤€ë¹„ ì‘ì—…
]);
```

### ìºì‹±

```typescript
// ìì£¼ ì‚¬ìš©ë˜ëŠ” ë°ì´í„° í’€ ìºì‹±
const DATA_POOL_CACHE = new Map();

async function loadDataPoolsCached(): Promise<DataPools> {
  const cacheKey = 'data_pools_v1';

  if (DATA_POOL_CACHE.has(cacheKey)) {
    return DATA_POOL_CACHE.get(cacheKey);
  }

  const pools = await loadDataPools();
  DATA_POOL_CACHE.set(cacheKey, pools);

  return pools;
}
```

---

## ğŸ“ ìš”ì•½

### ì™„ì „ ìë™í™”ëœ 5ë‹¨ê³„ íŒŒì´í”„ë¼ì¸

1. **Agent 1**: ìš•êµ¬ ë²¡í„° ë¶„ì„ (LLM)
2. **Agent 2**: ìºë¦­í„° í”„ë¡œíŒŒì¼ ìƒì„± (LLM + ë°ì´í„° í’€)
3. **Agent 3**: ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ì¡°ë¦½ (Handlebars)
4. **Agent 4**: ì´ë¯¸ì§€ í”„ë¡¬í”„íŠ¸ ìƒì„± (ê·œì¹™ ê¸°ë°˜)
5. **Agent 5**: ì´ë¯¸ì§€ ìƒì„± (Gemini Imagen)

### ê´€ë¦¬ì ê°œì… ë¶ˆí•„ìš”

- âœ… í…œí”Œë¦¿ë§Œ ì •ì˜í•˜ë©´ ìë™ ì‹¤í–‰
- âœ… ë°ì´í„° í’€ë§Œ ê´€ë¦¬í•˜ë©´ í’ˆì§ˆ í–¥ìƒ
- âœ… ëª¨ë‹ˆí„°ë§ë§Œ í•˜ë©´ ë¨

### 10-15ì´ˆ ë‚´ ì™„ì„±

- ê° Agent: 2-3ì´ˆ
- ì´ ì†Œìš”: 10-15ì´ˆ (ì´ë¯¸ì§€ ìƒì„± í¬í•¨)
